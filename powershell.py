import tkinter as tk
from tkinter import filedialog, messagebox
import os
from urllib.parse import urlparse
import re

# Define the output directory for "Create All Methods"
OUTPUT_DIR = r"E:\Notes\Macros\Cyber Security\Projects\scripts\PS1_Downloader\output"

def _write_ps1_file_content(url, selected_method, filename, execute_after_download, ps1_file_path):
    """
    Helper function to generate and write the .ps1 file content.
    """
    # Sanitize filename for use within PowerShell strings
    # PowerShell paths can handle spaces, but extra quotes are safer.
    # We'll ensure the filename passed to the PowerShell command is quoted.
    sanitized_filename_for_ps = filename.replace("'", "''") # Escape single quotes for PowerShell string

    ps1_content = f'''
# PowerShell Download Script generated by Python Tkinter App
# URL: {url}
# Method: {selected_method}
# Output File: {filename}

$url = '{url}'
$outputPath = '{sanitized_filename_for_ps}'

Write-Host "Attempting to download '$url' to '$outputPath' using '{selected_method}'..."

try {{
'''

    if selected_method == "Invoke-WebRequest (Recommended)":
        ps1_content += f'''
    # Invoke-WebRequest is a modern and robust cmdlet for web requests.
    # Requires PowerShell 3.0 or later.
    Invoke-WebRequest -Uri $url -OutFile $outputPath -ErrorAction Stop
'''
    elif selected_method == "System.Net.WebClient (DownloadFile)":
        ps1_content += f'''
    # System.Net.WebClient provides a simple way to download files using .NET.
    $wc = New-Object System.Net.WebClient
    $wc.DownloadFile($url, $outputPath)
'''
    elif selected_method == "BITS (Start-BitsTransfer)":
        ps1_content += f'''
    # Start-BitsTransfer leverages Background Intelligent Transfer Service for resilient downloads.
    # Good for large files and network interruptions. Requires BITS service running.
    $jobName = "PSDownload_{re.sub(r'[^a-zA-Z0-9_]', '', urlparse(url).hostname)}"
    $bitsJob = Start-BitsTransfer -Source $url -Destination $outputPath -DisplayName $jobName -Asynchronous -ErrorAction Stop

    Write-Host "BITS transfer started. Monitoring progress..."
    while ($bitsJob.JobState -eq 'Transferring' -or $bitsJob.JobState -eq 'Connecting' -or $bitsJob.JobState -eq 'Queued') {{
        Write-Progress -Activity "Downloading with BITS" -Status "$($bitsJob.BytesTransferred / 1MB):: $($bitsJob.BytesTotal / 1MB) MB" -PercentComplete (($bitsJob.BytesTransferred / $bitsJob.BytesTotal) * 100)
        Start-Sleep -Seconds 1
        $bitsJob = Get-BitsTransfer -JobId $bitsJob.JobId # Refresh job status
    }}

    if ($bitsJob.JobState -eq 'Transferred') {{
        Complete-BitsTransfer -BitsJob $bitsJob -ErrorAction Stop
    }} else {{
        throw "BITS transfer failed with state: $($bitsJob.JobState). Error: $($bitsJob.ErrorDescription)"
    }}
'''
    elif selected_method == "Curl.exe (Windows 10+)":
        ps1_content += f'''
    # Uses the curl.exe utility, which is built into Windows 10 and later.
    # -L follows redirects, -o specifies output file.
    $curlResult = & curl.exe -L -o $outputPath $url 2>&1
    if ($LASTEXITCODE -ne 0) {{
        throw "Curl.exe download failed. Exit Code: $LASTEXITCODE. Output: $curlResult"
    }}
'''
    elif selected_method == "Certutil.exe (Windows Built-in)":
        ps1_content += f'''
    # Certutil.exe is a command-line utility built into Windows.
    # -urlcache -f downloads the URL and saves it to the specified file.
    $certutilResult = & certutil.exe -urlcache -f $url $outputPath 2>&1
    # Certutil often returns 0 even on errors, so check for "Error" in output
    if ($certutilResult -like "*Error*" -or $LASTEXITCODE -ne 0) {{
        throw "Certutil.exe download failed. Output: $certutilResult"
    }}
'''
    else:
        raise ValueError(f"Unknown download method selected: {selected_method}")

    ps1_content += f'''
    Write-Host "Download complete: $outputPath"
}}
catch {{
    Write-Error "An error occurred during download: $($_.Exception.Message)"
    exit 1 # Exit with an error code
}}

'''

    # Add post-download execution
    if execute_after_download:
        ps1_content += f'''
# --- Execute after download ---
if (Test-Path $outputPath) {{
    Write-Host "Executing downloaded file: $outputPath"
    try {{
        Start-Process -FilePath $outputPath -Wait -ErrorAction Stop
        Write-Host "Execution complete."
    }}
    catch {{
        Write-Error "Failed to execute '$outputPath': $($_.Exception.Message)"
    }}
}} else {{
    Write-Warning "Cannot execute: Downloaded file not found at $outputPath."
}}
'''

    # Write the content to the .ps1 file
    with open(ps1_file_path, 'w') as f:
        f.write(ps1_content)

def generate_single_ps1_file():
    """
    Generates a single .ps1 file for the selected method, prompting for save location.
    """
    url = url_entry.get()
    selected_method = method_var.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return
    
    # Specific warnings for methods that might not handle all URL types well
    if "BITS" in selected_method and not (url.startswith("http://") or url.startswith("https://")):
        messagebox.showwarning("BITS Method Warning", "BITS method primarily supports HTTP/HTTPS URLs. FTP might not work directly.")
    
    if ("Curl.exe" in selected_method or "Certutil.exe" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("External Tool Warning", f"{selected_method} might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS.")

    try:
        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in filename:
            filename += ".dat"

        # Sanitize filename for Windows path compatibility
        filename = re.sub(r'[\\/:*?"<>|]', '_', filename)

        ps1_file_path = filedialog.asksaveasfilename(
            defaultextension=".ps1",
            filetypes=[("PowerShell Scripts", "*.ps1")],
            initialfile=f"download_with_{selected_method.split(' ')[0].lower()}.ps1",
            title="Save .ps1 File As"
        )

        if not ps1_file_path:
            return

        _write_ps1_file_content(url, selected_method, filename, execute_after_download, ps1_file_path)

        messagebox.showinfo(
            "Success",
            f"'{os.path.basename(ps1_file_path)}' created successfully!\n"
            f"You can find it at: {ps1_file_path}\n\n"
            f"To run, right-click and select 'Run with PowerShell', or execute from PowerShell console."
        )

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def create_all_ps1_files():
    """
    Creates a .ps1 file for each download method in the specified output directory.
    """
    url = url_entry.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL to create all files.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return

    try:
        # Create output directory if it doesn't exist
        os.makedirs(OUTPUT_DIR, exist_ok=True)

        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        base_filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in base_filename:
            base_filename += ".dat"
        
        # Sanitize base_filename for Windows path compatibility
        base_filename = re.sub(r'[\\/:*?"<>|]', '_', base_filename)

        created_files_count = 0
        failed_methods = []

        for method in download_methods:
            # Specific warnings/skips for methods that might not handle all URL types well
            if "BITS" in method and not (url.startswith("http://") or url.startswith("https://")):
                failed_methods.append(f"{method} (BITS primarily supports HTTP/HTTPS URLs)")
                continue
            
            if ("Curl.exe" in method or "Certutil.exe" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue

            # Sanitize method name for filename
            sanitized_method_name = re.sub(r'[\\/:*?"<>|()]', '', method).replace(' ', '_').replace('.', '').replace('&', '')
            
            # Construct the filename for the output ps1 file
            ps1_filename = f"download_{sanitized_method_name}.ps1"
            ps1_file_path = os.path.join(OUTPUT_DIR, ps1_filename)

            try:
                _write_ps1_file_content(url, method, base_filename, execute_after_download, ps1_file_path)
                created_files_count += 1
            except Exception as e:
                failed_methods.append(f"{method} ({e})")

        success_message = f"Successfully created {created_files_count} .ps1 files in:\n{OUTPUT_DIR}"
        if failed_methods:
            success_message += "\n\nFailed to create files for the following methods:\n" + "\n".join(failed_methods)
            messagebox.showwarning("Partial Success", success_message)
        else:
            messagebox.showinfo("Success", success_message)

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred while creating all files: {e}")

# --- GUI Setup ---
app = tk.Tk()
app.title("PowerShell (.ps1) Downloader Generator")
app.geometry("700x450") # Adjusted size
app.resizable(False, False)

# Configure grid for better layout
for i in range(5):
    app.grid_rowconfigure(i, weight=1)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=3)

# URL Label
url_label = tk.Label(app, text="Enter File URL:")
url_label.grid(row=0, column=0, padx=10, pady=10, sticky="e")

# URL Entry
url_entry = tk.Entry(app, width=50)
url_entry.grid(row=0, column=1, padx=10, pady=10, sticky="w")
url_entry.focus_set()

# Download Method Label
method_label = tk.Label(app, text="Select Download Method:")
method_label.grid(row=1, column=0, padx=10, pady=10, sticky="e")

# Download Method Dropdown (OptionMenu)
download_methods = [
    "Invoke-WebRequest (Recommended)",
    "System.Net.WebClient (DownloadFile)",
    "BITS (Start-BitsTransfer)",
    "Curl.exe (Windows 10+)",
    "Certutil.exe (Windows Built-in)"
]
method_var = tk.StringVar(app)
method_var.set(download_methods[0]) # Set default value

method_dropdown = tk.OptionMenu(app, method_var, *download_methods)
method_dropdown.config(width=40) # Adjust width
method_dropdown.grid(row=1, column=1, padx=10, pady=10, sticky="w")

# Execute After Download Checkbox
execute_var = tk.BooleanVar() # Variable to store checkbox state
execute_checkbox = tk.Checkbutton(app, text="Execute after download", variable=execute_var)
execute_checkbox.grid(row=2, column=1, padx=10, pady=5, sticky="w")

# Buttons
generate_button = tk.Button(app, text="Generate Single .PS1 File", command=generate_single_ps1_file)
generate_button.grid(row=3, column=0, columnspan=2, pady=10)

create_all_button = tk.Button(app, text="Create All Methods", command=create_all_ps1_files)
create_all_button.grid(row=4, column=0, columnspan=2, pady=10)

# Run the application
app.mainloop()
