import tkinter as tk
from tkinter import filedialog, messagebox
import os
from urllib.parse import urlparse
import re

# Define the output directory for "Create All Methods"
OUTPUT_DIR = r"E:\Notes\Macros\Cyber Security\Projects\scripts\PL_Downloader\output"

def _write_pl_file_content(url, selected_method, filename, execute_after_download, pl_file_path):
    """
    Helper function to generate and write the .pl (Perl) file content.
    """
    # Sanitize filename for use within Perl strings (Windows paths)
    # Perl strings can handle backslashes, but it's good practice to escape single quotes.
    sanitized_filename_for_pl = filename.replace("'", "\\'")

    pl_content = f'''
# Perl Download Script generated by Python Tkinter App
# This script is designed to be run with a Perl interpreter on Windows.
# URL: {url}
# Method: {selected_method}
# Output File: {filename}

use strict;
use warnings;
use autodie; # Automatically dies on failed system calls, file operations etc.

my $url = '{url}';
my $outputPath = '{sanitized_filename_for_pl}';

print "Attempting to download '$url' to '$outputPath' using '{selected_method}'...\\n";

'''

    if selected_method == "LWP::Simple (Recommended)":
        pl_content += f'''
# Requires LWP::Simple module. Install with: cpan LWP::Simple
use LWP::Simple;

my $status = getstore($url, $outputPath);

if (is_success($status)) {{
    print "Download complete: $outputPath\\n";
}} else {{
    die "Error during download (LWP::Simple). HTTP Status: $status\\n";
}}
'''
    elif selected_method == "HTTP::Tiny":
        pl_content += f'''
# Requires HTTP::Tiny module. Install with: cpan HTTP::Tiny
use HTTP::Tiny;

my $http = HTTP::Tiny->new();
my $response = $http->mirror($url, $outputPath);

if ($response->{{success}}) {{
    print "Download complete: $outputPath\\n";
}} else {{
    die "Error during download (HTTP::Tiny). Status: $response->{{status}}, Reason: $response->{{reason}}\\n";
}}
'''
    elif selected_method == "IO::Socket::INET (Manual HTTP)":
        pl_content += f'''
# This method manually constructs an HTTP GET request.
# It's more complex but doesn't require LWP::Simple or HTTP::Tiny.
# Limited error handling compared to higher-level modules.
use IO::Socket::INET;
use URI;

my $uri = URI->new($url);
my $host = $uri->host;
my $port = $uri->port || ($uri->scheme eq 'https' ? 443 : 80);
my $path = $uri->path_query || '/';

# For HTTPS, you would need IO::Socket::SSL and Net::SSLeay
if ($uri->scheme eq 'https') {{
    die "HTTPS not directly supported by this manual method without IO::Socket::SSL. Use LWP::Simple or HTTP::Tiny for HTTPS.\\n";
}}

my $sock = IO::Socket::INET->new(
    PeerAddr => $host,
    PeerPort => $port,
    Proto    => 'tcp',
) or die "Cannot connect to $host:$port: $!\\n";

my $request = "GET $path HTTP/1.1\\r\\n" .
              "Host: $host\\r\\n" .
              "Connection: close\\r\\n" .
              "User-Agent: PerlDownloader/1.0\\r\\n" .
              "\\r\\n";

$sock->print($request);

my $header = '';
my $line;
while (defined($line = $sock->getline())) {{
    $header .= $line;
    last if $line eq "\\r\\n"; # End of headers
}}

# Check HTTP status code (simple check for 200 OK)
if ($header !~ /^HTTP\\/1\\.\\d\\s+200\\s+OK/i) {{
    die "HTTP request failed or returned non-200 status.\\nHeader: $header\\n";
}}

open(my $fh, '>', $outputPath) or die "Cannot open $outputPath for writing: $!\\n";
binmode $fh; # Ensure binary mode for file writing

my $bytes_read;
my $buffer;
while ($bytes_read = $sock->read($buffer, 4096)) {{ # Read in chunks
    print $fh $buffer;
}}
close $fh;
$sock->close();

print "Download complete: $outputPath\\n";
'''
    elif selected_method == "Curl (via system command)":
        pl_content += f'''
# Requires curl.exe to be installed and in the system's PATH.
my $command = "curl.exe -L -o \\"$outputPath\\" \\"$url\\"";
print "Executing command: $command\\n";
my $exit_code = system($command);

if ($exit_code == 0) {{
    print "Download complete: $outputPath\\n";
}} else {{
    die "Curl command failed. Exit code: $exit_code\\n";
}}
'''
    elif selected_method == "Wget (via system command)":
        pl_content += f'''
# Requires wget.exe to be installed and in the system's PATH.
my $command = "wget.exe --no-check-certificate -O \\"$outputPath\\" \\"$url\\"";
print "Executing command: $command\\n";
my $exit_code = system($command);

if ($exit_code == 0) {{
    print "Download complete: $outputPath\\n";
}} else {{
    die "Wget command failed. Exit code: $exit_code\\n";
}}
'''
    else:
        # Corrected: Use Python's ValueError instead of Perl's die
        raise ValueError(f"Unknown download method selected: {selected_method}")

    pl_content += f'''
# --- Execute after download ---
if (-e $outputPath) {{ # Check if file exists
    print "Executing downloaded file: $outputPath\\n";
    # Use 'start' command on Windows to open the file with its default application
    my $exec_command = "start \\"\\" \\"$outputPath\\"";
    system($exec_command);
    print "Execution command sent.\\n";
}} else {{
    print "Cannot execute: Downloaded file not found at $outputPath.\\n";
}}

# Pause for user to see output if run directly from command line
print "Press Enter to exit...";
<STDIN>;
'''

    # Write the content to the .pl file
    with open(pl_file_path, 'w') as f:
        f.write(pl_content)

def generate_single_pl_file():
    """
    Generates a single .pl file for the selected method, prompting for save location.
    """
    url = url_entry.get()
    selected_method = method_var.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return
    
    # Specific warnings for methods that might not handle all URL types well
    if selected_method == "IO::Socket::INET (Manual HTTP)" and url.startswith("https://"):
        messagebox.showwarning("Method Warning", "IO::Socket::INET (Manual HTTP) does not directly support HTTPS. Use LWP::Simple or HTTP::Tiny for HTTPS.")
        return # Prevent generation if HTTPS is selected for this method
    
    if ("LWP::Simple" in selected_method or "HTTP::Tiny" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("Method Warning", f"{selected_method} might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS or a dedicated FTP client.")
    
    if ("Curl" in selected_method or "Wget" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("External Tool Warning", f"{selected_method} might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS.")

    try:
        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in filename:
            filename += ".dat"

        # Sanitize filename for Windows path compatibility
        filename = re.sub(r'[\\/:*?"<>|]', '_', filename)

        pl_file_path = filedialog.asksaveasfilename(
            defaultextension=".pl",
            filetypes=[("Perl Scripts", "*.pl")],
            initialfile=f"download_with_{selected_method.split(' ')[0].lower()}.pl",
            title="Save .pl File As"
        )

        if not pl_file_path:
            return

        _write_pl_file_content(url, selected_method, filename, execute_after_download, pl_file_path)

        messagebox.showinfo(
            "Success",
            f"'{os.path.basename(pl_file_path)}' created successfully!\n"
            f"You can find it at: {pl_file_path}\n\n"
            f"To run, execute from your terminal using 'perl {os.path.basename(pl_file_path)}'."
        )

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def create_all_pl_files():
    """
    Creates a .pl file for each download method in the specified output directory.
    """
    url = url_entry.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL to create all files.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return

    try:
        # Create output directory if it doesn't exist
        os.makedirs(OUTPUT_DIR, exist_ok=True)

        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        base_filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in base_filename:
            base_filename += ".dat"
        
        # Sanitize base_filename for Windows path compatibility
        base_filename = re.sub(r'[\\/:*?"<>|]', '_', base_filename)

        created_files_count = 0
        failed_methods = []

        for method in download_methods:
            # Specific warnings/skips for methods that might not handle all URL types well
            if method == "IO::Socket::INET (Manual HTTP)" and url.startswith("https://"):
                failed_methods.append(f"{method} (Does not support HTTPS directly)")
                continue
            
            if ("LWP::Simple" in method or "HTTP::Tiny" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue
            
            if ("Curl" in method or "Wget" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue

            # Sanitize method name for filename
            sanitized_method_name = re.sub(r'[\\/:*?"<>|()]', '', method).replace(' ', '_').replace('.', '').replace('&', '')
            
            # Construct the filename for the output pl file
            pl_filename = f"download_{sanitized_method_name}.pl"
            pl_file_path = os.path.join(OUTPUT_DIR, pl_filename)

            try:
                _write_pl_file_content(url, method, base_filename, execute_after_download, pl_file_path)
                created_files_count += 1
            except Exception as e:
                failed_methods.append(f"{method} ({e})")

        success_message = f"Successfully created {created_files_count} .pl files in:\n{OUTPUT_DIR}"
        if failed_methods:
            success_message += "\n\nFailed to create files for the following methods:\n" + "\n".join(failed_methods)
            messagebox.showwarning("Partial Success", success_message)
        else:
            messagebox.showinfo("Success", success_message)

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred while creating all files: {e}")

# --- GUI Setup ---
app = tk.Tk()
app.title("Perl (.pl) Downloader Generator")
app.geometry("750x480") # Adjusted size
app.resizable(False, False)

# Configure grid for better layout
for i in range(5):
    app.grid_rowconfigure(i, weight=1)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=3)

# URL Label
url_label = tk.Label(app, text="Enter File URL:")
url_label.grid(row=0, column=0, padx=10, pady=10, sticky="e")

# URL Entry
url_entry = tk.Entry(app, width=50)
url_entry.grid(row=0, column=1, padx=10, pady=10, sticky="w")
url_entry.focus_set()

# Download Method Label
method_label = tk.Label(app, text="Select Download Method:")
method_label.grid(row=1, column=0, padx=10, pady=10, sticky="e")

# Download Method Dropdown (OptionMenu)
download_methods = [
    "LWP::Simple (Recommended)",
    "HTTP::Tiny",
    "IO::Socket::INET (Manual HTTP)",
    "Curl (via system command)",
    "Wget (via system command)"
]
method_var = tk.StringVar(app)
method_var.set(download_methods[0]) # Set default value

method_dropdown = tk.OptionMenu(app, method_var, *download_methods)
method_dropdown.config(width=40) # Adjust width
method_dropdown.grid(row=1, column=1, padx=10, pady=10, sticky="w")

# Execute After Download Checkbox
execute_var = tk.BooleanVar() # Variable to store checkbox state
execute_checkbox = tk.Checkbutton(app, text="Execute after download", variable=execute_var)
execute_checkbox.grid(row=2, column=1, padx=10, pady=5, sticky="w")

# Buttons
generate_button = tk.Button(app, text="Generate Single .PL File", command=generate_single_pl_file)
generate_button.grid(row=3, column=0, columnspan=2, pady=10)

create_all_button = tk.Button(app, text="Create All Methods", command=create_all_pl_files)
create_all_button.grid(row=4, column=0, columnspan=2, pady=10)

# Run the application
app.mainloop()
