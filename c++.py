import tkinter as tk
from tkinter import filedialog, messagebox
import os
from urllib.parse import urlparse
import re

# Define the output directory for "Create All Methods"
OUTPUT_DIR = r"E:\Notes\Macros\Cyber Security\Projects\scripts\CPP_Downloader\output"

def _write_cpp_file_content(url, selected_method, filename, execute_after_download, cpp_file_path):
    """
    Helper function to generate and write the .cpp file content.
    """
    # Sanitize filename for use within C++ strings (Windows paths)
    sanitized_filename_for_cpp = filename.replace("\\", "\\\\") # Escape backslashes

    cpp_content = f'''
// C++ Download Script generated by Python Tkinter App
// This script is designed to be compiled and run on Windows.
// URL: {url}
// Method: {selected_method}
// Output File: {filename}

#include <iostream>
#include <string>
#include <windows.h> // For WinAPI functions
#include <urlmon.h>  // For URLDownloadToFile
#include <winhttp.h> // For WinHTTP API
#include <vector>    // For WinHTTP buffer

// Linker directives (for MSVC)
#pragma comment(lib, "urlmon.lib")
#pragma comment(lib, "winhttp.lib")

// Function to convert std::string to std::wstring (for wide character APIs)
std::wstring s2ws(const std::string& s)
{{
    int len;
    int slength = (int)s.length() + 1;
    len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0);
    wchar_t* buf = new wchar_t[len];
    MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, buf, len);
    std::wstring r(buf);
    delete[] buf;
    return r;
}}

int main()
{{
    std::string url_str = "{url}";
    std::string output_path_str = "{sanitized_filename_for_cpp}";

    std::wcout << L"Attempting to download '" << s2ws(url_str)
               << L"' to '" << s2ws(output_path_str)
               << L"' using '{selected_method}'..." << std::endl;

    HRESULT hr = S_OK;

    // Convert string to wide string for WinAPI functions
    LPCWSTR url_w = s2ws(url_str).c_str();
    LPCWSTR output_path_w = s2ws(output_path_str).c_str();

'''

    if selected_method == "URLDownloadToFile (Recommended)":
        cpp_content += f'''
    // URLDownloadToFile is a simple function for downloading files from a URL.
    // It's part of the URL Moniker API.
    hr = URLDownloadToFile(NULL, url_w, output_path_w, 0, NULL);

    if (SUCCEEDED(hr))
    {{
        std::wcout << L"Download complete: " << s2ws(output_path_str) << std::endl;
    }}
    else
    {{
        std::wcerr << L"Error during download (URLDownloadToFile). HRESULT: 0x"
                   << std::hex << hr << std::endl;
        // Common errors: INET_E_CANNOT_CONNECT, INET_E_RESOURCE_NOT_FOUND, E_ACCESSDENIED
        return 1; // Indicate error
    }}
'''
    elif selected_method == "WinHTTP API":
        cpp_content += f'''
    // WinHTTP provides a high-level interface to the HTTP protocol.
    // It offers more control over requests and responses.

    HINTERNET hSession = NULL, hConnect = NULL, hRequest = NULL;
    DWORD dwBytesRead = 0;
    std::vector<char> buffer(4096); // 4KB buffer

    // 1. Initialize WinHTTP session
    hSession = WinHttpOpen(L"WinHTTP Downloader/1.0",
                           WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                           WINHTTP_NO_PROXY_NAME,
                           WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSession)
    {{
        std::wcerr << L"Error WinHttpOpen: " << GetLastError() << std::endl;
        return 1;
    }}

    // Parse URL to get host and path
    URL_COMPONENTS urlComp;
    ZeroMemory(&urlComp, sizeof(urlComp));
    urlComp.dwStructSize = sizeof(urlComp);

    // Set required component lengths to get them
    urlComp.dwHostNameLength = -1;
    urlComp.dwUrlPathLength = -1;
    urlComp.dwExtraInfoLength = -1;

    if (!WinHttpCrackUrl(url_w, (DWORD)wcslen(url_w), 0, &urlComp))
    {{
        std::wcerr << L"Error WinHttpCrackUrl: " << GetLastError() << std::endl;
        WinHttpCloseHandle(hSession);
        return 1;
    }}

    std::wstring host(urlComp.lpszHostName, urlComp.dwHostNameLength);
    std::wstring path(urlComp.lpszUrlPath, urlComp.dwUrlPathLength);

    // 2. Connect to the HTTP server
    hConnect = WinHttpConnect(hSession, host.c_str(), urlComp.nPort, 0);
    if (!hConnect)
    {{
        std::wcerr << L"Error WinHttpConnect: " << GetLastError() << std::endl;
        WinHttpCloseHandle(hSession);
        return 1;
    }}

    // 3. Create an HTTP request handle
    hRequest = WinHttpOpenRequest(hConnect, L"GET", path.c_str(),
                                  NULL, WINHTTP_NO_REFERER,
                                  WINHTTP_DEFAULT_ACCEPT_TYPES,
                                  (urlComp.nPort == INTERNET_DEFAULT_HTTPS_PORT) ? WINHTTP_FLAG_SECURE : 0);
    if (!hRequest)
    {{
        std::wcerr << L"Error WinHttpOpenRequest: " << GetLastError() << std::endl;
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return 1;
    }}

    // 4. Send the request
    if (!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0,
                            WINHTTP_NO_REQUEST_DATA, 0, 0, 0))
    {{
        std::wcerr << L"Error WinHttpSendRequest: " << GetLastError() << std::endl;
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return 1;
    }}

    // 5. Receive the response
    if (!WinHttpReceiveResponse(hRequest, NULL))
    {{
        std::wcerr << L"Error WinHttpReceiveResponse: " << GetLastError() << std::endl;
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return 1;
    }}

    // 6. Read data and save to file
    HANDLE hFile = CreateFileW(output_path_w, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {{
        std::wcerr << L"Error creating file: " << GetLastError() << std::endl;
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return 1;
    }}

    do
    {{
        if (!WinHttpReadData(hRequest, buffer.data(), (DWORD)buffer.size(), &dwBytesRead))
        {{
            std::wcerr << L"Error WinHttpReadData: " << GetLastError() << std::endl;
            CloseHandle(hFile);
            WinHttpCloseHandle(hRequest);
            WinHttpCloseHandle(hConnect);
            WinHttpCloseHandle(hSession);
            return 1;
        }}

        if (dwBytesRead == 0)
            break; // No more data

        DWORD dwBytesWritten = 0;
        if (!WriteFile(hFile, buffer.data(), dwBytesRead, &dwBytesWritten, NULL))
        {{
            std::wcerr << L"Error writing to file: " << GetLastError() << std::endl;
            CloseHandle(hFile);
            WinHttpCloseHandle(hRequest);
            WinHttpCloseHandle(hConnect);
            WinHttpCloseHandle(hSession);
            return 1;
        }}

    }} while (dwBytesRead > 0);

    CloseHandle(hFile);
    std::wcout << L"Download complete: " << s2ws(output_path_str) << std::endl;

    // Clean up handles
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);
'''
    else:
        raise ValueError(f"Unknown download method selected: {selected_method}")

    cpp_content += f'''
    // --- Execute after download ---
    if (PathFileExistsW(output_path_w)) // Check if file exists
    {{
        std::wcout << L"Executing downloaded file: " << s2ws(output_path_str) << std::endl;
        // Use ShellExecute to open the file with its default associated program
        HINSTANCE hInst = ShellExecuteW(NULL, L"open", output_path_w, NULL, NULL, SW_SHOWNORMAL);
        if ((int)hInst <= 32) // ShellExecute returns <= 32 on error
        {{
            std::wcerr << L"Failed to execute '" << s2ws(output_path_str) << L"'. Error code: " << (int)hInst << std::endl;
        }}
        else
        {{
            std::wcout << L"Execution command sent." << std::endl;
        }}
    }}
    else
    {{
        std::wcout << L"Cannot execute: Downloaded file not found at " << s2ws(output_path_str) << L"." << std::endl;
    }}

    // Pause console for user to see output
    std::wcout << L"Press any key to exit...";
    std::wcin.ignore(); // Clear any leftover input
    std::wcin.get();    // Wait for a key press

    return 0;
}}
'''

    # Write the content to the .cpp file
    with open(cpp_file_path, 'w') as f:
        f.write(cpp_content)

def generate_single_cpp_file():
    """
    Generates a single .cpp file for the selected method, prompting for save location.
    """
    url = url_entry.get()
    selected_method = method_var.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return
    
    # Specific warnings for methods that might not handle all URL types well
    if selected_method == "URLDownloadToFile (Recommended)" and url.startswith("ftp://"):
        messagebox.showwarning("Method Warning", "URLDownloadToFile might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS.")
    
    if selected_method == "WinHTTP API" and url.startswith("ftp://"):
        messagebox.showwarning("Method Warning", "WinHTTP API is primarily for HTTP/HTTPS. FTP support is not direct.")

    try:
        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in filename:
            filename += ".dat"

        # Sanitize filename for Windows path compatibility
        filename = re.sub(r'[\\/:*?"<>|]', '_', filename)

        cpp_file_path = filedialog.asksaveasfilename(
            defaultextension=".cpp",
            filetypes=[("C++ Source Files", "*.cpp")],
            initialfile=f"download_with_{selected_method.split(' ')[0].lower()}.cpp",
            title="Save .cpp File As"
        )

        if not cpp_file_path:
            return

        _write_cpp_file_content(url, selected_method, filename, execute_after_download, cpp_file_path)

        messagebox.showinfo(
            "Success",
            f"'{os.path.basename(cpp_file_path)}' created successfully!\n"
            f"You can find it at: {cpp_file_path}\n\n"
            f"To compile (MSVC): cl {os.path.basename(cpp_file_path)} /EHsc urlmon.lib winhttp.lib\n"
            f"Then run the generated .exe file."
        )

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def create_all_cpp_files():
    """
    Creates a .cpp file for each download method in the specified output directory.
    """
    url = url_entry.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL to create all files.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return

    try:
        # Create output directory if it doesn't exist
        os.makedirs(OUTPUT_DIR, exist_ok=True)

        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        base_filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in base_filename:
            base_filename += ".dat"
        
        # Sanitize base_filename for Windows path compatibility
        base_filename = re.sub(r'[\\/:*?"<>|]', '_', base_filename)

        created_files_count = 0
        failed_methods = []

        for method in download_methods:
            # Specific warnings/skips for methods that might not handle all URL types well
            if method == "URLDownloadToFile (Recommended)" and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue
            
            if method == "WinHTTP API" and url.startswith("ftp://"):
                failed_methods.append(f"{method} (WinHTTP API is primarily for HTTP/HTTPS)")
                continue

            # Sanitize method name for filename
            sanitized_method_name = re.sub(r'[\\/:*?"<>|()]', '', method).replace(' ', '_').replace('.', '').replace('&', '')
            
            # Construct the filename for the output cpp file
            cpp_filename = f"download_{sanitized_method_name}.cpp"
            cpp_file_path = os.path.join(OUTPUT_DIR, cpp_filename)

            try:
                _write_cpp_file_content(url, method, base_filename, execute_after_download, cpp_file_path)
                created_files_count += 1
            except Exception as e:
                failed_methods.append(f"{method} ({e})")

        success_message = f"Successfully created {created_files_count} .cpp files in:\n{OUTPUT_DIR}"
        if failed_methods:
            success_message += "\n\nFailed to create files for the following methods:\n" + "\n".join(failed_methods)
            messagebox.showwarning("Partial Success", success_message)
        else:
            messagebox.showinfo("Success", success_message)

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred while creating all files: {e}")

# --- GUI Setup ---
app = tk.Tk()
app.title("C++ (.cpp) Downloader Generator")
app.geometry("750x480") # Adjusted size
app.resizable(False, False)

# Configure grid for better layout
for i in range(5):
    app.grid_rowconfigure(i, weight=1)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=3)

# URL Label
url_label = tk.Label(app, text="Enter File URL:")
url_label.grid(row=0, column=0, padx=10, pady=10, sticky="e")

# URL Entry
url_entry = tk.Entry(app, width=50)
url_entry.grid(row=0, column=1, padx=10, pady=10, sticky="w")
url_entry.focus_set()

# Download Method Label
method_label = tk.Label(app, text="Select Download Method:")
method_label.grid(row=1, column=0, padx=10, pady=10, sticky="e")

# Download Method Dropdown (OptionMenu)
download_methods = [
    "URLDownloadToFile (Recommended)",
    "WinHTTP API"
]
method_var = tk.StringVar(app)
method_var.set(download_methods[0]) # Set default value

method_dropdown = tk.OptionMenu(app, method_var, *download_methods)
method_dropdown.config(width=40) # Adjust width
method_dropdown.grid(row=1, column=1, padx=10, pady=10, sticky="w")

# Execute After Download Checkbox
execute_var = tk.BooleanVar() # Variable to store checkbox state
execute_checkbox = tk.Checkbutton(app, text="Execute after download", variable=execute_var)
execute_checkbox.grid(row=2, column=1, padx=10, pady=5, sticky="w")

# Buttons
generate_button = tk.Button(app, text="Generate Single .CPP File", command=generate_single_cpp_file)
generate_button.grid(row=3, column=0, columnspan=2, pady=10)

create_all_button = tk.Button(app, text="Create All Methods", command=create_all_cpp_files)
create_all_button.grid(row=4, column=0, columnspan=2, pady=10)

# Run the application
app.mainloop()
