import tkinter as tk
from tkinter import filedialog, messagebox
import os
from urllib.parse import urlparse
import re

# Define the output directory for "Create All Methods"
OUTPUT_DIR = r"E:\Notes\Macros\Cyber Security\Projects\scripts\PHP_Downloader\output"

def _write_php_file_content(url, selected_method, filename, execute_after_download, php_file_path):
    """
    Helper function to generate and write the .php file content.
    """
    # Sanitize filename for use within PHP strings (Windows paths)
    # PHP strings can handle backslashes, but escape single quotes and backslashes for safety.
    sanitized_filename_for_php = filename.replace("\\", "\\\\").replace("'", "\\'")

    php_content = f'''<?php
// PHP Download Script generated by Python Tkinter App
// This script is designed to be run with a PHP CLI interpreter on Windows.
// URL: {url}
// Method: {selected_method}
// Output File: {filename}

$url = '{url}';
$outputPath = '{sanitized_filename_for_php}';

echo "Attempting to download '{{$url}}' to '{{$outputPath}}' using '{selected_method}'...\\n";

try {{
'''

    if selected_method == "file_get_contents (Recommended)":
        php_content += f'''
    // file_get_contents is simple and effective for HTTP/HTTPS downloads.
    // Requires allow_url_fopen to be enabled in php.ini.
    $fileContent = file_get_contents($url);
    if ($fileContent === FALSE) {{
        throw new Exception("Failed to get content from URL: {{$url}}");
    }}
    if (file_put_contents($outputPath, $fileContent) === FALSE) {{
        throw new Exception("Failed to write content to file: {{$outputPath}}");
    }}
'''
    elif selected_method == "cURL (Requires Extension)":
        php_content += f'''
    // cURL is a powerful library for making network requests.
    // Requires the PHP cURL extension to be enabled in php.ini.
    if (!extension_loaded('curl')) {{
        throw new Exception("PHP cURL extension is not enabled. Please enable it in php.ini.");
    }}

    $ch = curl_init($url);
    if ($ch === FALSE) {{
        throw new Exception("Failed to initialize cURL.");
    }}

    $fp = fopen($outputPath, 'wb');
    if ($fp === FALSE) {{
        throw new Exception("Failed to open output file for writing: {{$outputPath}}");
    }}

    curl_setopt($ch, CURLOPT_FILE, $fp);
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); // Follow redirects
    curl_setopt($ch, CURLOPT_FAILONERROR, true); // Fail on HTTP errors (4xx, 5xx)

    $success = curl_exec($ch);
    if ($success === FALSE) {{
        $error = curl_error($ch);
        curl_close($ch);
        fclose($fp);
        throw new Exception("cURL download failed: {{$error}}");
    }}

    curl_close($ch);
    fclose($fp);
'''
    elif selected_method == "fopen & stream_copy_to_stream":
        php_content += f'''
    // Uses basic file stream functions for downloading.
    // Requires allow_url_fopen to be enabled in php.ini.
    $source = fopen($url, 'rb');
    if ($source === FALSE) {{
        throw new Exception("Failed to open URL stream: {{$url}}");
    }}

    $destination = fopen($outputPath, 'wb');
    if ($destination === FALSE) {{
        fclose($source);
        throw new Exception("Failed to open output file for writing: {{$outputPath}}");
    }}

    $bytesCopied = stream_copy_to_stream($source, $destination);
    if ($bytesCopied === FALSE) {{
        fclose($source);
        fclose($destination);
        throw new Exception("Failed to copy stream data.");
    }}

    fclose($source);
    fclose($destination);
'''
    elif selected_method == "wget (via shell_exec)":
        php_content += f'''
    // Requires wget.exe to be installed and in the system's PATH.
    // shell_exec might be disabled for security reasons in some PHP configurations.
    $command = "wget.exe --no-check-certificate -O \\"{{$outputPath}}\\" \\"{{$url}}\\" 2>&1";
    echo "Executing command: {{$command}}\\n";
    $output = shell_exec($command);
    
    // Check for common wget error indicators
    if (strpos($output, 'ERROR') !== false || strpos($output, 'failed') !== false) {{
        throw new Exception("wget command failed. Output: {{$output}}");
    }}
'''
    elif selected_method == "curl (via shell_exec)":
        php_content += f'''
    // Requires curl.exe to be installed (built into Windows 10+).
    // shell_exec might be disabled for security reasons in some PHP configurations.
    $command = "curl.exe -L -o \\"{{$outputPath}}\\" \\"{{$url}}\\" 2>&1";
    echo "Executing command: {{$command}}\\n";
    $output = shell_exec($command);

    // Check for common curl error indicators (curl.exe typically returns 0 on success)
    // A more robust check would involve checking $? for the exit code, but shell_exec doesn't provide it directly.
    // We rely on checking output for errors.
    if (strpos($output, 'curl: (') !== false || strpos($output, 'error') !== false) {{
        throw new Exception("curl command failed. Output: {{$output}}");
    }}
'''
    else:
        raise ValueError(f"Unknown download method selected: {selected_method}")

    php_content += f'''
    echo "Download complete: {{$outputPath}}\\n";
}} catch (Exception $e) {{
    echo "An error occurred during download: " . $e->getMessage() . "\\n";
    exit(1); // Exit with an error code
}}

'''

    # Add post-download execution
    if execute_after_download:
        php_content += f'''
// --- Execute after download ---
if (file_exists($outputPath)) {{
    echo "Executing downloaded file: {{$outputPath}}\\n";
    // Use 'start' command on Windows to open the file with its default application
    $exec_command = "start \\"\\" \\"{{$outputPath}}\\"";
    $exec_output = shell_exec($exec_command);
    echo "Execution command sent.\\n";
}} else {{
    echo "Cannot execute: Downloaded file not found at {{$outputPath}}.\\n";
}}

// Pause for user to see output if run directly from command line
echo "Press Enter to exit...";
trim(fgets(STDIN)); // Wait for user input
?>
'''

    # Write the content to the .php file
    with open(php_file_path, 'w') as f:
        f.write(php_content)

def generate_single_php_file():
    """
    Generates a single .php file for the selected method, prompting for save location.
    """
    url = url_entry.get()
    selected_method = method_var.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return
    
    # Specific warnings for methods that might not handle all URL types well
    if ("file_get_contents" in selected_method or "fopen" in selected_method or "cURL" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("Method Warning", f"{selected_method} might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS or a dedicated FTP client.")
    
    if ("wget" in selected_method or "curl" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("External Tool Warning", f"{selected_method} might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS.")

    try:
        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in filename:
            filename += ".dat"

        # Sanitize filename for Windows path compatibility
        filename = re.sub(r'[\\/:*?"<>|]', '_', filename)

        php_file_path = filedialog.asksaveasfilename(
            defaultextension=".php",
            filetypes=[("PHP Scripts", "*.php")],
            initialfile=f"download_with_{selected_method.split(' ')[0].lower()}.php",
            title="Save .php File As"
        )

        if not php_file_path:
            return

        _write_php_file_content(url, selected_method, filename, execute_after_download, php_file_path)

        messagebox.showinfo(
            "Success",
            f"'{os.path.basename(php_file_path)}' created successfully!\n"
            f"You can find it at: {php_file_path}\n\n"
            f"To run, execute from your terminal using 'php {os.path.basename(php_file_path)}'."
        )

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def create_all_php_files():
    """
    Creates a .php file for each download method in the specified output directory.
    """
    url = url_entry.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL to create all files.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return

    try:
        # Create output directory if it doesn't exist
        os.makedirs(OUTPUT_DIR, exist_ok=True)

        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        base_filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in base_filename:
            base_filename += ".dat"
        
        # Sanitize base_filename for Windows path compatibility
        base_filename = re.sub(r'[\\/:*?"<>|]', '_', base_filename)

        created_files_count = 0
        failed_methods = []

        for method in download_methods:
            # Specific warnings/skips for methods that might not handle all URL types well
            if ("file_get_contents" in method or "fopen" in method or "cURL" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue
            
            if ("wget" in method or "curl" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue

            # Sanitize method name for filename
            sanitized_method_name = re.sub(r'[\\/:*?"<>|()]', '', method).replace(' ', '_').replace('.', '').replace('&', '')
            
            # Construct the filename for the output php file
            php_filename = f"download_{sanitized_method_name}.php"
            php_file_path = os.path.join(OUTPUT_DIR, php_filename)

            try:
                _write_php_file_content(url, method, base_filename, execute_after_download, php_file_path)
                created_files_count += 1
            except Exception as e:
                failed_methods.append(f"{method} ({e})")

        success_message = f"Successfully created {created_files_count} .php files in:\n{OUTPUT_DIR}"
        if failed_methods:
            success_message += "\n\nFailed to create files for the following methods:\n" + "\n".join(failed_methods)
            messagebox.showwarning("Partial Success", success_message)
        else:
            messagebox.showinfo("Success", success_message)

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred while creating all files: {e}")

# --- GUI Setup ---
app = tk.Tk()
app.title("PHP (.php) Downloader Generator")
app.geometry("750x480") # Adjusted size
app.resizable(False, False)

# Configure grid for better layout
for i in range(5):
    app.grid_rowconfigure(i, weight=1)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=3)

# URL Label
url_label = tk.Label(app, text="Enter File URL:")
url_label.grid(row=0, column=0, padx=10, pady=10, sticky="e")

# URL Entry
url_entry = tk.Entry(app, width=50)
url_entry.grid(row=0, column=1, padx=10, pady=10, sticky="w")
url_entry.focus_set()

# Download Method Label
method_label = tk.Label(app, text="Select Download Method:")
method_label.grid(row=1, column=0, padx=10, pady=10, sticky="e")

# Download Method Dropdown (OptionMenu)
download_methods = [
    "file_get_contents (Recommended)",
    "cURL (Requires Extension)",
    "fopen & stream_copy_to_stream",
    "wget (via shell_exec)",
    "curl (via shell_exec)"
]
method_var = tk.StringVar(app)
method_var.set(download_methods[0]) # Set default value

method_dropdown = tk.OptionMenu(app, method_var, *download_methods)
method_dropdown.config(width=40) # Adjust width
method_dropdown.grid(row=1, column=1, padx=10, pady=10, sticky="w")

# Execute After Download Checkbox
execute_var = tk.BooleanVar() # Variable to store checkbox state
execute_checkbox = tk.Checkbutton(app, text="Execute after download", variable=execute_var)
execute_checkbox.grid(row=2, column=1, padx=10, pady=5, sticky="w")

# Buttons
generate_button = tk.Button(app, text="Generate Single .PHP File", command=generate_single_php_file)
generate_button.grid(row=3, column=0, columnspan=2, pady=10)

create_all_button = tk.Button(app, text="Create All Methods", command=create_all_php_files)
create_all_button.grid(row=4, column=0, columnspan=2, pady=10)

# Run the application
app.mainloop()
