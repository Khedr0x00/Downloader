import tkinter as tk
from tkinter import filedialog, messagebox
import os
from urllib.parse import urlparse
import re

# Define the output directory for "Create All Methods"
OUTPUT_DIR = r"E:\Notes\Macros\Cyber Security\Projects\scripts\NodeJS_Downloader\output"

def _write_nodejs_file_content(url, selected_method, filename, execute_after_download, js_file_path):
    """
    Helper function to generate and write the .js (Node.js) file content.
    """
    # Sanitize filename for use within Node.js strings (Windows paths)
    sanitized_filename_for_js = filename.replace("\\", "\\\\").replace("'", "\\'")

    nodejs_content = f'''// Node.js Download Script generated by Python Tkinter App
// This script is designed to be run with Node.js.
// URL: {url}
// Method: {selected_method}
// Output File: {filename}

const fs = require('fs');
const path = require('path');
const {{ URL }} = require('url');
const {{ spawn, exec }} = require('child_process');

const url = '{url}';
const outputPath = '{sanitized_filename_for_js}';

console.log(`Attempting to download '${{url}}' to '${{outputPath}}' using '{selected_method}'...`);

async function downloadFile() {{
    try {{
'''

    if selected_method == "HTTPS/HTTP Module (Built-in)":
        nodejs_content += f'''
        const protocol = new URL(url).protocol === 'https:' ? require('https') : require('http');

        await new Promise((resolve, reject) => {{
            const fileStream = fs.createWriteStream(outputPath);
            protocol.get(url, (response) => {{
                if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {{
                    // Handle redirects manually if needed, or rely on Node.js default behavior (often follows)
                    console.log(`Redirecting to: ${{response.headers.location}}`);
                    // For simplicity, this example doesn't re-initiate the request.
                    // A more robust solution would recursively call downloadFile with the new URL.
                    reject(new Error(`Redirect detected. Status: ${{response.statusCode}}`));
                    return;
                }}
                if (response.statusCode !== 200) {{
                    reject(new Error(`Download failed. HTTP Status: ${{response.statusCode}}`));
                    return;
                }}
                response.pipe(fileStream);
                fileStream.on('finish', () => {{
                    fileStream.close();
                    resolve();
                }});
                fileStream.on('error', (err) => {{
                    fs.unlink(outputPath, () => reject(err)); // Delete the partial file
                }});
            }}).on('error', (err) => {{
                fs.unlink(outputPath, () => reject(err)); // Delete the partial file
            }});
        }});
'''
    elif selected_method == "axios (Requires npm install)":
        nodejs_content += f'''
        // Requires axios library. Install with: npm install axios
        const axios = require('axios');

        const response = await axios({{
            method: 'get',
            url: url,
            responseType: 'stream'
        }});

        if (response.status !== 200) {{
            throw new Error(`Download failed. HTTP Status: ${{response.status}}`);
        }}

        const writer = fs.createWriteStream(outputPath);
        response.data.pipe(writer);

        await new Promise((resolve, reject) => {{
            writer.on('finish', resolve);
            writer.on('error', reject);
        }});
'''
    elif selected_method == "node-fetch (Requires npm install)":
        nodejs_content += f'''
        // Requires node-fetch library. Install with: npm install node-fetch
        const fetch = require('node-fetch');

        const response = await fetch(url);
        if (!response.ok) {{
            throw new Error(`Download failed. HTTP Status: ${{response.status}}`);
        }}

        const fileStream = fs.createWriteStream(outputPath);
        await new Promise((resolve, reject) => {{
            response.body.pipe(fileStream);
            response.body.on('error', (err) => {{
                fs.unlink(outputPath, () => reject(err)); // Delete the partial file
            }});
            fileStream.on('finish', () => {{
                fileStream.close();
                resolve();
            }});
            fileStream.on('error', (err) => {{
                fs.unlink(outputPath, () => reject(err)); // Delete the partial file
            }});
        }});
'''
    elif selected_method == "Curl (via child_process)":
        nodejs_content += f'''
        // Requires curl.exe to be installed (built into Windows 10+).
        // For other OS, ensure curl is in PATH.
        await new Promise((resolve, reject) => {{
            const curl = spawn('curl', ['-L', '-o', outputPath, url]);

            curl.stdout.on('data', (data) => {{
                console.log(`curl stdout: ${{data}}`);
            }});

            curl.stderr.on('data', (data) => {{
                console.error(`curl stderr: ${{data}}`);
            }});

            curl.on('close', (code) => {{
                if (code === 0) {{
                    resolve();
                }} else {{
                    reject(new Error(`Curl command failed with exit code ${{code}}`));
                }}
            }});
            curl.on('error', (err) => {{
                reject(new Error(`Failed to start curl process: ${{err.message}}`));
            }});
        }});
'''
    elif selected_method == "Wget (via child_process)":
        nodejs_content += f'''
        // Requires wget.exe to be installed and in the system's PATH.
        await new Promise((resolve, reject) => {{
            const wget = spawn('wget', ['--no-check-certificate', '-O', outputPath, url]);

            wget.stdout.on('data', (data) => {{
                console.log(`wget stdout: ${{data}}`);
            }});

            wget.stderr.on('data', (data) => {{
                console.error(`wget stderr: ${{data}}`);
            }});

            wget.on('close', (code) => {{
                if (code === 0) {{
                    resolve();
                }} else {{
                    reject(new Error(`Wget command failed with exit code ${{code}}`));
                }}
            }});
            wget.on('error', (err) => {{
                reject(new Error(`Failed to start wget process: ${{err.message}}`));
            }});
        }});
'''
    else:
        raise ValueError(f"Unknown download method selected: {selected_method}")

    nodejs_content += f'''
        console.log(`Download complete: ${{outputPath}}`);
    }} catch (error) {{
        console.error(`An error occurred during download: ${{error.message}}`);
        process.exit(1); // Exit with an error code
    }}

'''

    # Add post-download execution
    if execute_after_download:
        nodejs_content += f'''
    // --- Execute after download ---
    if (fs.existsSync(outputPath)) {{
        console.log(`Executing downloaded file: ${{outputPath}}`);
        try {{
            let command;
            switch (process.platform) {{
                case 'win32':
                    command = `start "" "${{outputPath}}"`;
                    break;
                case 'darwin': // macOS
                    command = `open "${{outputPath}}"`;
                    break;
                default: // Linux
                    command = `xdg-open "${{outputPath}}"`;
            }}
            exec(command, (error, stdout, stderr) => {{
                if (error) {{
                    console.error(`Failed to execute '${{outputPath}}': ${{error.message}}`);
                    return;
                }}
                if (stdout) console.log(`Execution stdout: ${{stdout}}`);
                if (stderr) console.error(`Execution stderr: ${{stderr}}`);
                console.log("Execution command sent.");
            }});
        }} catch (e) {{
            console.error(`Failed to initiate execution for '${{outputPath}}': ${{e.message}}`);
        }}
    }} else {{
        console.log(`Cannot execute: Downloaded file not found at ${{outputPath}}.`);
    }}
}}

downloadFile();
'''

    # Write the content to the .js file
    with open(js_file_path, 'w') as f:
        f.write(nodejs_content)

def generate_single_nodejs_file():
    """
    Generates a single .js file for the selected method, prompting for save location.
    """
    url = url_entry.get()
    selected_method = method_var.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return
    
    # Specific warnings for methods that might not handle all URL types well
    if ("HTTPS/HTTP Module" in selected_method or "axios" in selected_method or "node-fetch" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("Method Warning", f"{selected_method} is primarily for HTTP/HTTPS. FTP support is not direct.")
    
    if ("Curl" in selected_method or "Wget" in selected_method) and url.startswith("ftp://"):
        messagebox.showwarning("External Tool Warning", f"{selected_method} might have limited or no direct support for FTP URLs. Consider HTTP/HTTPS.")

    try:
        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in filename:
            filename += ".dat"

        # Sanitize filename for Windows path compatibility
        filename = re.sub(r'[\\/:*?"<>|]', '_', filename)

        js_file_path = filedialog.asksaveasfilename(
            defaultextension=".js",
            filetypes=[("Node.js Scripts", "*.js")],
            initialfile=f"download_with_{selected_method.split(' ')[0].lower()}.js",
            title="Save .js File As"
        )

        if not js_file_path:
            return

        _write_nodejs_file_content(url, selected_method, filename, execute_after_download, js_file_path)

        messagebox.showinfo(
            "Success",
            f"'{os.path.basename(js_file_path)}' created successfully!\n"
            f"You can find it at: {js_file_path}\n\n"
            f"To run, execute from your terminal using 'node {os.path.basename(js_file_path)}'."
        )

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")

def create_all_nodejs_files():
    """
    Creates a .js file for each download method in the specified output directory.
    """
    url = url_entry.get()
    execute_after_download = execute_var.get()

    if not url:
        messagebox.showwarning("Input Error", "Please enter a valid URL to create all files.")
        return

    if not (url.startswith("http://") or url.startswith("https://") or url.startswith("ftp://")):
        messagebox.showwarning("Invalid URL", "URL must start with http://, https://, or ftp://")
        return

    try:
        # Create output directory if it doesn't exist
        os.makedirs(OUTPUT_DIR, exist_ok=True)

        parsed_url = urlparse(url)
        path_segments = parsed_url.path.split('/')
        base_filename = path_segments[-1] if path_segments[-1] else "downloaded_file"
        if '.' not in base_filename:
            base_filename += ".dat"
        
        # Sanitize base_filename for Windows path compatibility
        base_filename = re.sub(r'[\\/:*?"<>|]', '_', base_filename)

        created_files_count = 0
        failed_methods = []

        for method in download_methods:
            # Specific warnings/skips for methods that might not handle all URL types well
            if ("HTTPS/HTTP Module" in method or "axios" in method or "node-fetch" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Primarily for HTTP/HTTPS)")
                continue
            
            if ("Curl" in method or "Wget" in method) and url.startswith("ftp://"):
                failed_methods.append(f"{method} (Limited/no direct support for FTP URLs)")
                continue

            # Sanitize method name for filename
            sanitized_method_name = re.sub(r'[\\/:*?"<>|()]', '', method).replace(' ', '_').replace('.', '').replace('&', '')
            
            # Construct the filename for the output js file
            js_filename = f"download_{sanitized_method_name}.js"
            js_file_path = os.path.join(OUTPUT_DIR, js_filename)

            try:
                _write_nodejs_file_content(url, method, base_filename, execute_after_download, js_file_path)
                created_files_count += 1
            except Exception as e:
                failed_methods.append(f"{method} ({e})")

        success_message = f"Successfully created {created_files_count} .js files in:\n{OUTPUT_DIR}"
        if failed_methods:
            success_message += "\n\nFailed to create files for the following methods:\n" + "\n".join(failed_methods)
            messagebox.showwarning("Partial Success", success_message)
        else:
            messagebox.showinfo("Success", success_message)

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred while creating all files: {e}")

# --- GUI Setup ---
app = tk.Tk()
app.title("Node.js (.js) Downloader Generator")
app.geometry("750x480") # Adjusted size
app.resizable(False, False)

# Configure grid for better layout
for i in range(5):
    app.grid_rowconfigure(i, weight=1)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=3)

# URL Label
url_label = tk.Label(app, text="Enter File URL:")
url_label.grid(row=0, column=0, padx=10, pady=10, sticky="e")

# URL Entry
url_entry = tk.Entry(app, width=50)
url_entry.grid(row=0, column=1, padx=10, pady=10, sticky="w")
url_entry.focus_set()

# Download Method Label
method_label = tk.Label(app, text="Select Download Method:")
method_label.grid(row=1, column=0, padx=10, pady=10, sticky="e")

# Download Method Dropdown (OptionMenu)
download_methods = [
    "HTTPS/HTTP Module (Built-in)",
    "axios (Requires npm install)",
    "node-fetch (Requires npm install)",
    "Curl (via child_process)",
    "Wget (via child_process)"
]
method_var = tk.StringVar(app)
method_var.set(download_methods[0]) # Set default value

method_dropdown = tk.OptionMenu(app, method_var, *download_methods)
method_dropdown.config(width=40) # Adjust width
method_dropdown.grid(row=1, column=1, padx=10, pady=10, sticky="w")

# Execute After Download Checkbox
execute_var = tk.BooleanVar() # Variable to store checkbox state
execute_checkbox = tk.Checkbutton(app, text="Execute after download", variable=execute_var)
execute_checkbox.grid(row=2, column=1, padx=10, pady=5, sticky="w")

# Buttons
generate_button = tk.Button(app, text="Generate Single .JS File", command=generate_single_nodejs_file)
generate_button.grid(row=3, column=0, columnspan=2, pady=10)

create_all_button = tk.Button(app, text="Create All Methods", command=create_all_nodejs_files)
create_all_button.grid(row=4, column=0, columnspan=2, pady=10)

# Run the application
app.mainloop()
